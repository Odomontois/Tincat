\import Cat
\import Category
\import Functor
\import Logic
\import Paths
\import Unique
\import Universal.Limit
\import Cat.Free
\open PullbackDiagramm
\open Free (FreeCatFunctor)
\open FreeCatFunctor (mapId, toFunctor)

\record PullbackData {a b c : C} (p : C) (f : a ->> c) (g : b ->> c) \extends BasePrecat{
  | pi1 : p ->> a
  | pi2 : p ->> b

  \property cross : f `o` pi1 = g `o` pi2
  \property pullback {x : C} (xa : x ->> a) (xb : x ->> b) (xc : f `o` xa = g `o` xb) :
  Unique (x ->> p) (\lam pr => \Sigma (pi1 `o` pr = xa) (pi2 `o` pr = xb))

  \func  dob (dx : Obj) : C
    | DA => a
    | DB => b
    | DC => c

  \func dmap {x y : Obj} (f : Arr x y) : dob x ->> dob y \elim x, y, f
    | DA, DC, A->C => f
    | DB, DC, B->C => g


  \func freeFunct => \new FreeCatFunctor Arr C dob dmap
  \func diagramm : Functor (freeCat Arr) C => FreeCatFunctor.toFunctor {freeFunct}

  \func dedge (x : Obj) : p ->> dob x
    | DA => pi1
    | DB => pi2
    | DC => f `o` pi1




  \lemma dcone {x y : Obj} (f : Free Arr x y) : diagramm.map f `o` dedge x = dedge y \elim f
    | free-id x=y => dcode-id x=y
    | free-comp {m} m->y f' => {?} \where {
    \lemma dcone-idp {x : Obj} (p : x = x) : diagramm.map (free-id p) `o` dedge x = dedge x =>
      pmap (\lam e => FreeCatFunctor.mapId {freeFunct} e right `o` dedge x) (Path.inProp p idp) *> C.id-right (dedge x)

    \lemma dcode-id {x y : Obj} (p : x = y) : diagramm.map (free-id p)  `o` dedge x = dedge y \elim x, y
      | DA, DA => dcone-idp p
      | DA, DB => absurd (discrAB p)
      | DA, DC => absurd (discrAC p)
      | DB, DA => absurd (discrAB (inv p))
      | DB, DB => dcone-idp p
      | DB, DC => absurd (discrBC p)
      | DC, DA => absurd (discrAC (inv p))
      | DC, DB => absurd (discrBC (inv p))
      | DC, DC => dcone-idp p
  }
}

\open PullbackData

\record Pullback \extends PullbackData, Limit {
  | tip => p
  | IX => freeCat Arr
  | D => diagramm
  | edge => dedge
}

\module PullbackDiagramm \where{
  \data Obj | DA | DB | DC

  \func discrOb1 (o : Obj) : \Prop
    | DA => \Sigma
    | DB => Empty
    | DC => Empty

  \func discrOb2 (o : Obj) : \Prop
    | DA => Empty
    | DB => \Sigma
    | DC => Empty

  \lemma discrAB (p : DA = DB) : Empty => transport discrOb1 p ()

  \lemma discrAC (p : DA = DC) : Empty => transport discrOb1 p ()

  \lemma discrBC (p : DB = DC) : Empty => transport discrOb2 p ()

  \data Arr (dom cod : Obj) \with
    | DA, DC => A->C
    | DB, DC => B->C
}


