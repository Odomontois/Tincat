\import Cat
\import Equiv (QEquiv)
\import Universal.Limit
\import Iso
\import Data.Bool
\import Unique
\import Paths
\import Data.Three
\import Universal.Object
\import Category
\import Data.Three
\open Precat (>>)
\import Equiv.Univalence (=-to-Equiv, QEquiv-to-=)
\import Function (-o)
\import Functor (Functor)
\import Set.Category
\import Data.Or

\record LargeProduct {X : \Set} (pget : X -> C) \extends Limit {
  | IX => discreteCat X
  | D => Functor.discreteFunctor pget

  | pob : C
  | proj (i : X) : pob ->> pget i
  | lprod (x : C) (f : \Pi (i : X) -> x ->> pget i) : Unique (x ->> pob ) (\lam pr => \Pi (j : X) -> proj j `o` pr = f j)

  | tip => pob
  | edge (ix : IX) => proj ix
  | cone {ix1 ix2 : IX} (f : ix1 = ix2) =>
    coe (\lam i => coe(\lam j => pget ix1 ->> pget (f @ j)) (id (pget ix1)) i `o` proj ix1 = proj (f @ i))  (id-right _)  right
  | universal (c : Cone D) =>  lprod c.tip c.edge
} \where {
  \lemma product-unique {C : Precat} {I : \Set} {a : I -> C.Ob} (pr pr' : LargeProduct a) :
    Iso1 (elem {pr'.lprod pr.pob pr.proj}) \cowith
    | rev => elem {pr.lprod pr'.pob pr'.proj}
    | l_comp => iso-one-side pr' pr
    | r_comp => iso-one-side pr pr'
    \where {
      \open Unique (elem)

      \func iso-one-side {C : Precat} {I : \Set } {a : I -> C} (pr pr' : LargeProduct a) :
        elem {pr'.lprod pr.pob pr.proj} `o` elem {pr.lprod pr'.pob pr'.proj} = id pr'.pob =>
        \let | f : Unique => pr'.lprod pr.pob pr.proj
             | f-1 : Unique => pr.lprod pr'.pob pr'.proj
             | res : pr'.pob ->> pr'.pob  => f.elem `o` f-1.elem
             | eqs (i : pr.X) : pr'.proj i `o` res = pr'.proj i => o-assoc _ _ _ *> pmap (>> f-1.elem) (f.prop i) *> f-1.prop i
        \in product_eq_id pr' res eqs

      \func product_eq_id {C : Precat} (P : LargeProduct {C}) (f : P.pob ->> P.pob ) (eqs : \Pi (i : P.X) -> P.proj i `o` f = P.proj i) : f = id _ =>
        \let | u : Unique => P.lprod P.pob (P.proj)
             | u_eq_id => u.unique (id _) (\lam i => C.id-left (P.proj i))
             | u_eq_f => u.unique f eqs
        \in (inv u_eq_f) *> u_eq_id
    }
}

\record Product2 (a b : C) \extends LargeProduct {
  | pi1 : pob ->> a
  | pi2 : pob ->> b
  \property prod2 {x : C.Ob} (f : x ->> a) (g : x ->> b) : Unique (x ->> pob) (\lam pr => \Sigma (pi1 `o`  pr = f) (pi2 `o` pr = g))

  | X => Bool
  | pget i => \case i \with {| true => a | false => b }
  | proj i => \case i \as k \return pob ->> pget k \with {| true => pi1 | false => pi2 }
  | lprod x f  =>
    \let p2 : Unique => prod2 (f true) (f false)
    \in \new Unique _ _ p2.elem {
      | prop j => \case j \as k \return (proj k `o` p2.elem = f k) \with {| true => p2.prop.1 | false => p2.prop.2}
      | unique q g => p2.unique q (g true, g false)
    }

} \where {
  \func swap {C : Precat} {a b p : C} (pab : Product2 p a b) : Product2 p b a \cowith
    | pi1 => pab.pi2
    | pi2 => pab.pi1
    | prod2 {x} f g =>
      \let f*g : Unique (x ->> p) => pab.prod2 g f
      \in \new Unique f*g.A _ {
        | elem => f*g.elem
        | prop => (f*g.prop.2, f*g.prop.1)
        | unique u pu => f*g.unique u (pu.2, pu.1)
      }

  \lemma swap-involutive {C : Precat} (a b p : C) (pab : Product2 p a b) : swap (swap pab) = pab => idp

  \func product_associativity {C : Precat} (a b c pab pab_c pbc pa_bc : C)
                              (a*b : Product2 pab a b )
                              (ab*c : Product2 pab_c pab c )
                              (b*c : Product2 pbc b c)
                              (a*bc : Product2 pa_bc a pbc) : pab_c ~= pa_bc => {?}
    \where {
      \func threeProduct {C : Precat} {a b c pab pab_c : C} (a*b : Product2 pab a b ) (ab*c : Product2 pab_c pab c ) :
        LargeProduct {C} {three} (make3X a b c) =>
        \let
          | proj (i : three) => \case i \as i' \return pab_c ->> make3X a b c i' \with {
            | t1 => a*b.pi1 `o` ab*c.pi1
            | t2 => a*b.pi2 `o` ab*c.pi1
            | t3 => ab*c.pi2
          }
        \in \new LargeProduct _ {
          | pob => pab_c
          | proj => proj
          | lprod c f =>
            \let | uab : Unique (c ->> pab) => a*b.prod2 (f t1) (f t2)
                 | uab_c : Unique (c ->> pab_c) => ab*c.prod2 uab.elem (f t3)
            \in \new Unique _ _ {
              | elem => uab_c.elem
              | prop i => \case i \as i' \return proj i' `o` uab_c.elem = f i' \with {
                | t1 => inv (o-assoc _ _ _) *> pmap (o a*b.pi1) uab_c.prop.1 *> uab.prop.1
                | t2 => inv (o-assoc _ _ _) *> pmap (o a*b.pi2) uab_c.prop.1 *> uab.prop.2
                | t3 => uab_c.prop.2
              }
              | unique g gu =>
                \let gab => uab.unique (ab*c.pi1 `o` g) (o-assoc _ _ _ *> gu t1, o-assoc _ _ _ *> gu t2)
                \in uab_c.unique g (inv gab, gu t3)
            }
        }
    }
}

\func LargeSum {C : Precat} {X : \Set} (pget : X -> C) => LargeProduct  {op C} {X} pget

\func Sum2 {C : Precat} (cp a b : C) => Product2 {op C} cp a b

--
--\func product_associativity {C : PreCat} (a b c : PreCat.Ob {C})
--                            (pab : Product2 {C} a b)
--                            (pab_c : Product2 {C} pab.p c )
--                            (pbc : Product2 {C} b c)
--                            (pa_bc : Product2 {C} a pbc.p) : pab_c.p ~= {C} pa_bc.p =>
--  product_ob_unique
--      (prod_of_prod_ass_l a b c pab pab_c)
--      (prod_of_prod_ass_r a b c pbc pa_bc)
--  \where{
--    \func prod_of_prod_ass_l {C : PreCat} (a b c : C.Ob)
--                             (pab : Product2 {C} a b) (pab_c : Product2 {C} pab.p c)
--      : LargeProduct {C} three (make3X a b c) pab_c.p =>
--      \let
--        | ob   => make3X a b c
--        | pi idx => \case idx \as i \return (C.Hom pab_c.p (ob i)) \with {
--          | el3_1 => pab.pi1 cmp {C} pab_c.pi1
--          | el3_2 => pab.pi2 cmp {C} pab_c.pi1
--          | el3_3 => pab_c.pi2
--        }
--        | prod (x : C.Ob) (f : \Pi (i : three) -> C.Hom x (ob i)) =>
--          \let
--            | ut m => \Pi (i : three) -> (pi i cmp {C} m = f i)
--            | pab_x : Unique => pab.prod x (f el3_1) (f el3_2)
--            | pab_c_x : Unique => pab_c.prod x pab_x.elem (f el3_3)
--            | pm => pab_c_x.elem
--            | prop idx => \case idx \as i \return (pi i cmp {C} pm = f i) \with {
--              | el3_1 => C.assoc (pab.pi1) (pab_c.pi1) pm *> transport (\lam m => pab.pi1 cmp {C} m = f el3_1) (inv pab_c_x.prop.1) pab_x.prop.1
--              | el3_2 => C.assoc (pab.pi2) (pab_c.pi1) pm *> transport (\lam m => pab.pi2 cmp {C} m = f el3_2) (inv pab_c_x.prop.1) pab_x.prop.2
--              | el3_3 => pab_c_x.prop.2
--            }
--            | uni (am : C.Hom x pab_c.p) (am_eqs : ut am) : pm = am =>
--              \let | eq1 : pab_x.elem = pab_c.pi1 cmp {C} am => pab_x.unique (pab_c.pi1 cmp {C} am) (
--                inv (ass {C}) *> (am_eqs el3_1),
--                inv (ass {C}) *> (am_eqs el3_2)
--              )
--              \in pab_c_x.unique am (inv eq1 , am_eqs el3_3)
--
--          \in \new Unique (x ->> {C} pab_c.p) ut pab_c_x.elem prop uni
--      \in \new LargeProduct {C} three ob pab_c.p {
--        | pi => pi
--        | lprod  => prod
--      }
--
--    \func prod_of_prod_ass_r {C : PreCat} (a b c : C.Ob)
--                             (pbc : Product2 {C} b c) (pa_bc : Product2 {C} a pbc.p)
--      : LargeProduct {C} three (make3X a b c) pa_bc.p =>
--      \let
--        | ob   => make3X a b c
--        | pi idx => \case idx \as i \return (C.Hom pa_bc.p (ob i)) \with {
--          | el3_1 => pa_bc.pi1
--          | el3_2 => pbc.pi1 cmp {C} pa_bc.pi2
--          | el3_3 => pbc.pi2 cmp {C} pa_bc.pi2
--        }
--        | prod (x : C.Ob) (f : \Pi (i : three) -> C.Hom x (ob i)) =>
--          \let
--            | ut m => \Pi (i : three) -> (pi i cmp {C} m = f i)
--            | pbc_x : Unique => pbc.prod x (f el3_2) (f el3_3)
--            | pa_bc_x : Unique => pa_bc.prod x  (f el3_1) pbc_x.elem
--            | pm => pa_bc_x.elem
--            | prop idx => \case idx \as i \return (pi i cmp {C} pm = f i) \with {
--              | el3_1 => pa_bc_x.prop.1
--              | el3_2 => C.assoc (pbc.pi1) (pa_bc.pi2) pm *> transport (\lam m => pbc.pi1 cmp {C} m = f el3_2) (inv pa_bc_x.prop.2) pbc_x.prop.1
--              | el3_3 => C.assoc (pbc.pi2) (pa_bc.pi2) pm *> transport (\lam m => pbc.pi2 cmp {C} m = f el3_3) (inv pa_bc_x.prop.2) pbc_x.prop.2
--            }
--            | uni (am : C.Hom x pa_bc.p) (am_eqs : ut am) : pm = am =>
--              \let | eq1 : pbc_x.elem = pa_bc.pi2 cmp {C} am => pbc_x.unique (pa_bc.pi2 cmp {C} am) (
--                inv (ass {C}) *> (am_eqs el3_2),
--                inv (ass {C}) *> (am_eqs el3_3)
--              )
--              \in pa_bc_x.unique am (am_eqs el3_1, inv eq1)
--
--          \in \new Unique ( x ->> {C} pa_bc.p) ut pa_bc_x.elem prop uni
--      \in \new LargeProduct {C} three ob pa_bc.p {
--        | pi => pi
--        | lprod  => prod
--      }
--  }


-- product object is unique up to isomorphism
--


\func product_shuffle {C : Cat} {IX IY : \Set} {k : IX -> C}  (p : C) (qe : QEquiv {IX} {IY}) (P : LargeProduct k p) =>
  \new LargeProduct (\lam y => k (qe.ret y)) p {
    | proj y => P.proj (qe.ret y)
    | lprod x ms =>
      \let
        | A => x ->> p
        | B (m : A) => \Pi (u : IY) -> P.proj (qe.ret u) `o` {C} m = ms u
        | orig : Unique (x ->> p) => P.lprod x (\lam (u : IX) => coe (\lam i => x ->> k (qe.ret_f u @ i))  (ms (qe.f u)) right )
      \in \new Unique A B {
        | elem => orig.elem
        | prop u =>
          \let | zzt i => x ->> k (qe.ret (inv (qe.f_sec u) @ i))
               | zz i  : zzt i  => ms ( inv (qe.f_sec u) @ i)
               | ut i => x ->> k (qe.ret_f (qe.ret u) @ i)
               | ms2 => ms (qe.f (qe.ret u))
               | ms2r : ms u = zz left => idp
               | ms2l : ms2 = zz right => idp
               | uul : coe ut ms2 left = ms2 => idp
               | uur : coe ut ms2 right = coe (\lam i => x ->> k (qe.ret_f (qe.ret u) @ i)) (ms (qe.f (qe.ret u))) right => idp
          \in orig.prop (qe.ret u) *> {?}

        | unique => {?}
      }
  }
