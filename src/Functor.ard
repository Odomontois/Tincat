\import Cat
\import SetCat (SetC, Set)
\import Paths

\record Functor (C D : \Type) {dom : PreCat C} {cod : PreCat D} {
  | ob : C -> D
  | map : \Pi {a b : C} (a ->> b) -> (ob a) ->> (ob b)
  \property functor_id : \Pi {a : C} -> map (dom.id {a}) = cod.id {ob a}
  \property func_comp : \Pi {a b c : C} (f : b ->> c) (g : a ->> b) ->  (map f) o (map g) = map (f o g)
}  \where {
  \func fop {C D : \Type} {cc : PreCat C} {dd : PreCat D}  (F : Functor C D) : Functor C D {op cc} {op dd} \cowith {
    | ob => F.ob
    | map {a} {b} => F.map {b} {a}
    | functor_id => F.functor_id
    | func_comp f g => F.func_comp g f
  }

  \func Id {C : \Type} {cc : PreCat C} : Functor C C  \cowith
    | ob x => x
    | map f => f
    | functor_id {a} => idp
    | func_comp f g => idp

  \func Comp {C D E : \Type } {cc : PreCat C} { dc : PreCat D} { ec : PreCat E} (F : Functor D E) (G : Functor C D) : Functor C E \cowith
    | ob x => F.ob (G.ob x)
    | map {a} {b} f => F.map (G.map f)
    | functor_id {a} => pmap F.map G.functor_id *> F.functor_id
    | func_comp {a} {b} {c} f g => F.func_comp (G.map f) (G.map g) *> pmap F.map (G.func_comp f g)

  \func Const {C D : \Type } {cc : PreCat C} {dc : PreCat D} (o : D) : Functor C D \cowith
    | ob _ => o
    | map _ => dc.id
    | functor_id {_} => idp
    | func_comp f g => dc.l_unit dc.id

  --  -- лолкот гарантирует
  --


  \func l_unit {C D : \Type} {cc : PreCat C} {dc : PreCat D} (F : Functor C D) : Comp {C} {D} {D} (Id {D}) F = F =>
    \let | compf : Functor C D => Comp {C} {D} {D} (Id {D}) F
         | eq_map {a b : C} : compf.map {a} {b} = F.map => idp
         | eq_fid {a : C} : compf.functor_id {a} = F.functor_id {a} => idp
         | eq_fcomp {a b c : C} (f : b ->> c) (g : a ->> b) : compf.func_comp  f g = F.func_comp f g => Path.inProp _ _
    \in path (\lam i => \new Functor C D {cc} {dc} {
      | ob a => F.ob a
      | map {a} {b} => eq_map  @ i
      | functor_id {a} => eq_fid @ i
      | func_comp  f g => eq_fcomp  f g @ i
    })

  --    \let | fcomp => Comp {C} {D} {D} Id F
  --         | F' => \new Functor C D F.ob F.map F.functor_id F.func_comp
  --         | eq : fcomp = F' => equiv F.ob F.map fcomp F'
  --         | eq2 : F' = F => idp
  --    \in eq *> eq2
  --
--  \func r_unit {C D : Cat} (F : Functor C D) : Comp {C} {C} {D} F Id = F =>
  --    \let | fcomp => Comp {C} {C} {D} F Id
  --         | F' => \new Functor C D F.ob F.map F.id F.comp
  --         | eq : fcomp = F' => equiv F.ob F.map fcomp F'
  --         | eq2 : F' = F => idp
  --    \in eq *> eq2
  --
--  \func assoc {A B C D : Cat} (F : Functor C D) (G : Functor B C) (H : Functor A B) :
  --    Comp (Comp {B} {C} {D} F G) H = {Functor A D} Comp F (Comp {A} {B} {C} G H) =>
  --    \let | left => Comp {A} {B} {D} (Comp {B} {C} {D} F G) H
  --         | right => Comp {A} {C} {D} F (Comp {A} {B} {C} G H)
  --    \in equiv {A} {D} (Functor.ob {left}) (Functor.map {left}) left right
  --}
  --
--\func homFunctor {C : Cat} (o : C.Ob) : Functor C SetC \cowith {
  --  | ob x => \new Set (C.Hom o x) (C.homSet {o} {x})
  --  | map f g => C.comp f g
  --  | id {a} => funExt (\lam _ => C.Hom o a) (_) (_) (\lam f => C.l_unit f)
  --  | comp {a} {b} {c} f g => funExt (\lam _ => C.Hom o c) (_) (_) (\lam h => inv (C.assoc f g h))

}