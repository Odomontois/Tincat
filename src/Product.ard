\import Cat
\import Iso
\import Unique
\import lib.Paths


\record Product
 {C : Cat} (I : \Set)
 (a : I -> C.Ob)
 (p : C.Ob)
 (pi : \Pi (i : I) -> p ->> {C} a i)
 (prod : \Pi (x : C.Ob) (f : \Pi (i : I) -> x ->> {C} a i) -> Unique (x ->> {C} p) (\lam pr => \Pi (j : I) -> pi j cmp {C} pr = f j) )


--product object is unique up to isomorphism
\func product_ob_unique {C : Cat} {I : \Set} {a : I -> C.Ob} (pr pr' : Product {C} I a) : pr.p ~= {C} pr'.p =>
      \new Iso {C} {pr.p} {pr'.p} {
       | f => elem {pr'.prod pr.p pr.pi}
       | f_op => elem {pr.prod pr'.p pr'.pi}
       | l_comp => iso_one_side pr' pr
       | r_comp => iso_one_side pr pr'
    } \where {
      \open Unique (elem)
      \func iso_one_side {C : Cat} {I : \Set } {a : I -> C.Ob } (pr pr' : Product {C} I a) :
        elem {pr'.prod pr.p pr.pi} cmp {C} elem {pr.prod pr'.p pr'.pi} = C.id =>
         \let | f : Unique => pr'.prod pr.p pr.pi
              | f-1 : Unique => pr.prod pr'.p pr'.pi
              | res => f.elem cmp {C} f-1.elem
              | eqs (i : pr.I)  => transport (\lam a => a = pr'.pi i) (C.assoc (pr'.pi i) f.elem f-1.elem)
                                                    (transport {C.Hom pr.p (pr.a i)}
                                                    (\lam h => h cmp {C} f-1.elem = pr'.pi i)
                                                    (inv (f.prop i)) (f-1.prop i))
         \in product_eq_id pr' res eqs

      \func product_eq_id {C : Cat}(P : Product {C}) (f : C.Hom P.p P.p ) (eqs : \Pi (i : P.I) -> P.pi i cmp {C} f = P.pi i) : f = C.id =>
          \let | u : Unique => P.prod P.p (P.pi)
               | u_eq_id => u.unique C.id (\lam i => C.r_unit (P.pi i))
               | u_eq_f => u.unique f eqs
          \in (inv u_eq_f) *> u_eq_id
    }

\record Product2
   {C : Cat}
   (a b : Cat.Ob {C})
   (p : C.Ob)
   (pi1 : p ->> {C} a)
   (pi2 : p ->> {C} b)
   (prod : \Pi (x : C.Ob) (f : x ->> {C} a) (g : x ->> {C} b) -> Unique (x ->> {C} p) (\lam pr => \Sigma
    (pi1 cmp {C} pr = f)
    (pi2 cmp {C} pr = g)
   ))


\func product_inv {C : Cat} (a b : Cat.Ob {C}) (pab : Product2 {C} a b) : Product2 {C} b a pab.p \cowith
    | pi1 => pab.pi2
    | pi2 => pab.pi1
    | prod x f1 f2 =>
        \let orig : Unique => pab.prod x f2 f1
        \in \new Unique orig.A {
          | B pr => \Sigma (pab.pi2 cmp {C} pr = f1) (pab.pi1 cmp {C} pr = f2)
          | elem => orig.elem
          | prop => (orig.prop.2, orig.prop.1)
          | unique f' prod' => orig.unique f' (prod'.2, prod'.1)
          }

\func product_symmetry {C : Cat} (a b : Cat.Ob {C}) (pab : Product2 {C} a b) : product_inv b a (product_inv a b pab) = pab => idp

\func product_associativity {C : Cat} (a b c : Cat.Ob {C})
         (pab : Product2 {C} a b)
         (pab_c : Product2 {C} pab.p c )
         (pbc : Product2 {C} b c)
         (pa_bc : Product2 {C} a pbc.p) : pab_c.p ~= {C} pa_bc.p => {?}

