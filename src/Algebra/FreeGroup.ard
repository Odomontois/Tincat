\import Algebra.Group
\import Algebra.Homo
\import Algebra.Monoid
\import Algebra.Pointed
\import Data.Bool
\import Paths
\import Prelude

\lemma inv-ide {A : Group} : inverse ide = {A} ide => inv (ide-right _) *> inverse-left _

\lemma inv-* {A : Group} (x y : A): inverse (x * y) = (inverse y) * (inverse x) =>
  cancel-left (x * y) (inverse (x * y)) (inverse y * inverse x) (
    inverse-right _ *>
    inv (inverse-right _) *>
    pmap (* x ) ( inv (ide-left _) *> pmap (\lam x' => x' * _) (inv (inverse-right y)) *> A.*-assoc y _ _) *>
    inv (A.*-assoc _ _ _)
  )

\truncated \data FreeGroup (A : \Set) : \Set
  | zero
  | cons Bool A (FreeGroup A)
  | cancel (b : Bool) (a : A) (t : FreeGroup A) (i : I) \elim i {
    | left => cons b a (cons (not b) a t)
    | right => t
  } \where {
  \lemma cancel' {A : \Set} (b : Bool) (a : A) (t : FreeGroup A) : cons (not b) a (cons b a t) = t =>
    pmap (\lam b' => cons (not b) a (cons b' a t)) (inv (not-inv b)) *> path (cancel (not b) a t)

  \func \infixl 5 plus {A : \Set} (x : FreeGroup A) (y : FreeGroup A) : FreeGroup A \elim x
    | zero => y
    | cons b a x => cons b a (x plus y)
    | cancel b a x i => cancel b a (x plus y) i

  \lemma not-inv (b : Bool) : not (not b) = b
    | true => idp
    | false => idp

  \func \infixl 5 minus {A : \Set} (x y : FreeGroup A) : FreeGroup A \elim y
    | zero => x
    | cons b a y => cons (not b) a x minus y
    | cancel b a y i => cancel' (not b) a x @ i minus y
    \where {
      \lemma minus-swap {A : \Set} (x y z : FreeGroup A) : x plus y minus z = x minus z plus y \elim z
        | zero => idp
        | cons b a z => minus-swap _ _ _

      \lemma double-neg {A : \Set} (x y z : FreeGroup A) : x minus (y minus z) = z plus x minus y \elim z
        | zero => idp
        | cons b a z => double-neg x _ z *>  pmap (\lam b' => cons b' a _ minus y) (not-inv b)

      \lemma minus-assoc {A : \Set} (x y z : FreeGroup A) : x minus (y plus z)  = x minus y minus z \elim y
        | zero => idp
        | cons b a y => minus-assoc _ _ _

      \lemma minus-cancel {A : \Set} (x : FreeGroup A) : x minus x = zero
        | zero => idp
        | cons b a x => pmap (\lam x' => x' minus x) (cancel' b a x) *> minus-cancel x
    }

  \func negate {A : \Set} (x : FreeGroup A) : FreeGroup A => zero minus x

  \lemma negate-inv {A : \Set} (x : FreeGroup A) : negate (negate x) = x => double-neg _ _ _ *> plus-zero x

  \lemma plus-zero {A : \Set} (x : FreeGroup A) : x plus zero = x
    | zero => idp
    | cons b a x => pmap (cons b a) (plus-zero x)

  \lemma plus-assoc{A : \Set} (x y z : FreeGroup A) : x plus y plus z = x plus (y plus z) \elim x
    | zero => idp
    | cons b a x => pmap (cons b a) (plus-assoc x y z)

  \open minus

  \lemma plus-negl {A : \Set} (x : FreeGroup A) : (negate x) plus x = zero =>
    inv (minus-swap _ _ _) *> minus-cancel x

  \lemma plus-negr {A : \Set} (x : FreeGroup A) : x plus (negate x)  = zero =>
    pmap (\lam x' => x' plus _) (inv (negate-inv _)) *> plus-negl (negate x)

  \record FoldMap {A : \Set} {B : Group} (f : A -> B){
    \func uinv (b : Bool) (x : B) : B \elim b
      | true => x
      | false => inverse x

    \lemma uinv-elim (b : Bool) (x : B) : uinv b x * uinv (not b) x = ide \elim b
      | true => inverse-right x
      | false => inverse-left x

    \func run (x : FreeGroup A) : B
      | zero => ide
      | cons b a x => (uinv b (f a)) * run x
      | cancel b a x i =>
        \let e : (uinv b (f a)) * ((uinv (not b) (f a)) * run x) = run x =>
               inv (B.*-assoc _ _ _) *> pmap (\lam a' => a' * _) (uinv-elim b _) *> B.ide-left _
        \in e @ i

    \lemma run-plus (x y : FreeGroup A) : run (x plus y) = run x * run y \elim x
      | zero => inv (ide-left _)
      | cons b a x => pmap (* (uinv b (f a))) (run-plus x y) *> inv (*-assoc _ _ _)

    \lemma run-minus (x y : FreeGroup A) : run (x minus y) = run x * inverse (run y) \elim y
      | zero => inv (ide-right _) *> pmap (* (run x)) (inv inv-ide)
      | cons b a y =>
        pmap run (minus-swap (cons (not b) a zero) x y) *>
        run-plus _ _ *>
        {?}

    --    \lemma run-negate (x : FreeGroup A) : run (negate x) = inverse (run x)
    --      | zero => inv inv-ide
    --      | cons true a x =>  {?} *> pmap (\lam x' => x' * _) (run-negate x) *> inv (inv-* _ _)
    --      | cons false a x => {?}

    \lemma isHomo : GroupHomo {freeGroup} run \cowith
      | zero-coh => idp
      | plus-coh x y => {?}
      | inv-coh x => {?}
  }

  \func foldMap {A : \Set} {B : Group} (f : A -> B) (x :  FreeGroup A) : B => FoldMap.run {\new FoldMap f} x
}

\open FreeGroup

\instance freeGroup {A : \Set} : Group (FreeGroup A)
  | ide => zero
  | * => plus
  | ide-left x => idp
  | ide-right => plus-zero
  | *-assoc => plus-assoc
  | inverse => negate
  | inverse-left  => plus-negl
  | inverse-right => plus-negr

