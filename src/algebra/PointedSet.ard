\import Cat
\import Set
\import SetCat
\import Terminal
\import Unique
\import lib.Data.Unit
\import lib.Equiv
\import lib.HLevel
\import lib.Paths

\record Pointed (base : S)
  \extends Set
  \where {
    \record Homo {A B : Pointed}
                 (h : A.S -> B.S)
                 (equ : h A.base = B.base)

    \func id {A : Pointed} : Homo {A} {A} \cowith {
      | h => Set.id A.S
      | equ => idp
      }

    \func comp {A B C : Pointed} (f : Homo {B} {C}) (g : Homo {A} {B}) : Homo {A} {C} \cowith {
      | h => Set.comp f.h g.h
      | equ => pmap f.h g.equ *> f.equ
      }

    \func equiv {A B : Pointed}(f g : Homo {A} {B})(e : f.h = g.h) : f = g =>
      \let | f' : Homo {A} {B} f.h => \new Homo f.h f.equ
           | g' : Homo {A} {B} g.h => \new Homo g.h g.equ
           | eqq (i : I) => \Pi (x : Homo {A} {B} f.h) (y : Homo {A} {B} (e @ i)) -> x = {Homo {A} {B}} y \in
      coe eqq (\lam (x y : Homo {A} {B} f.h) => path (\lam i => \new Homo f.h (((B.is_set (f.h A.base) B.base) x.equ y.equ) @ i))) right f' g'

    \func l_unit {A B : Pointed} (f : Homo {A} {B}) : comp {A} {B} {B} id f = f =>
      \let | composed : Homo {A} {B} => comp {A} {B} {B} id f
           | left : composed.h = f.h => Set.l_unit f.h \in
      equiv composed f left

    \func r_unit {A B : Pointed} (f : Homo {A} {B}) : comp {A} {A} {B} f id = f =>
      \let | composed : Homo {A} {B} => comp {A} {A} {B} f id
           | right : composed.h = f.h => Set.r_unit f.h \in
      equiv composed f right

    \func assoc {A B C D : Pointed}
                (e : Homo {C} {D})
                (f : Homo {B} {C})
                (g : Homo {A} {B}) : comp (comp {B} {C} {D} e f) g = {Homo {A} {D}} comp e (comp {A} {B} {C} f g) =>
      \let | left : Homo {A} {D} => comp (comp {B} {C} {D} e f) g
           | right : Homo {A} {D} => comp e (comp {A} {B} {C} f g)
           | ass : left.h = right.h => Set.assoc e.h f.h g.h \in
      equiv left right ass
  }

\func homo_isSet (p1 p2 : Pointed) : isSet (Pointed.Homo {p1} {p2}) =>
  \let | homoSigma => \Sigma (f : p1.S -> p2.S) (f p1.base = p2.base)
       | homoSigma_isSet => sigmaSet {p1.S -> p2.S} {\lam f => f p1.base = p2.base} (Set.hom_set p1 p2)
                                     (\lam f => isProp=>isSet (f p1.base = p2.base) (p2.is_set (f p1.base) p2.base))
       | sect => \new Section {
         | A => Pointed.Homo {p1} {p2}
         | B => homoSigma
         | f (x : Pointed.Homo {p1} {p2}) => (x.h, x.equ)
         | ret b => \new Pointed.Homo {p1} {p2} {
           | h => b.1
           | equ => b.2
           }
         | ret_f => qed
       }
  \in HLevel_-2+1=>HLevel_-1 (Pointed.Homo {p1} {p2}) 1
        (HLevel-retracts sect {2} ((HLevel_-1=>HLevel_-2+1 homoSigma 1 homoSigma_isSet)))

\func PointedCat : Cat {Pointed} \cowith {
  | Hom p1 p2 => Pointed.Homo {p1} {p2}
  | homSet {p1} {p2} => homo_isSet p1 p2
  | id => Pointed.id
  | comp f g => Pointed.comp f g
  | l_unit f => Pointed.l_unit f
  | r_unit f => Pointed.r_unit f
  | assoc {A} {B} {C} {D} f g h => Pointed.assoc {A} {B} {C} {D} f g h
  }

\func zero => \new Pointed (Unit) (unit_isSet) (unit)

\func terminal : Terminal {PointedCat} zero \cowith {
  | terminal P => \new Singleton {
    | T => P ->> {PointedCat} zero
    | t => \new Pointed.Homo {P} {zero} {
      | h x => unit
      | equ => idp
      }
    | prop (m1 m2 : Pointed.Homo {P} {zero}) =>
      Pointed.equiv m1 m2 (functExt (\lam x => unit_isProp (m1.h x) (m2.h x)))
    }
  }

\func initial : Initial {PointedCat} zero \cowith {
  | initial (P : Pointed) => \new Singleton {
    | T => zero ->> {PointedCat} P
    | t => \new Pointed.Homo {zero} {P} {
      | h x => P.base
      | equ => idp
      }
    | prop (m1 m2 : Pointed.Homo {zero} {P}) =>
       Pointed.equiv m1 m2 (functExt (\lam (x : Unit) => m1.equ *> (inv m2.equ)))
    }
  }
