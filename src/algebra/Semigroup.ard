\import Cat
\import Product
\import Set
\import SetCat
\import Terminal
\import Unique
\import lib.Data.Empty
\import lib.Data.Unit
\import lib.Equiv
\import lib.HLevel
\import lib.Paths

\record Semigroup (op : S -> S -> S)
                  (assoc : \Pi (x y z : S) -> op (op x y) z = op x (op y z)) \extends Set
  \where {
    \func \infixr 5 |+| {A : Semigroup} (x y : A.S) => A.op x y

    \record Homo {A B : Semigroup}
                 (h : A.S -> B.S)
                 (equ : \Pi (x y : A.S) -> h (x |+| {A} y) = h x |+| {B} h y)

    \func equiv {A B : Semigroup} (f g : Homo {A} {B})(e : f.h = g.h) : f = g =>
      \let | f' : Homo {A} {B} f.h => \new Homo f.h f.equ
           | g' : Homo {A} {B} g.h => \new Homo g.h g.equ
           | eqq (i : I) => \Pi (x : Homo {A} {B} f.h) (y : Homo {A} {B} (e @ i)) -> x = {Homo {A} {B}} y \in
      coe eqq (\lam (h1 h2 : Homo {A} {B} f.h) =>
        path (\lam i => \new Homo f.h (\lam x y =>
          ((B.is_set (f.h (x |+| {A} y)) (f.h x |+| {B} f.h y)) (h1.equ x y) (h2.equ x y)) @ i)
        )
      ) right f' g'

    \func equivElim {A B : Semigroup}{f g : Homo {A} {B}}(e : f = g) : f.h = g.h =>
      pmap {Homo {A} {B}} {A.S -> B.S} (\lam (x : Homo {A} {B}) => x.h) e

    \func id {A : Semigroup} : Homo {A} {A} \cowith {
      | h => Set.id
      | equ _ _ => idp
      }

    \func comp {A B C : Semigroup} (f : Homo {B} {C}) (g : Homo {A} {B}) : Homo {A} {C} \cowith {
      | h => Set.comp f.h g.h
      | equ => \lam x y =>
        pmap (\lam k => f.h k) (g.equ x y) *> f.equ (g.h x) (g.h y)
      }

    \func homo_isSet (A B : Semigroup) : isSet (Homo {A} {B}) =>
      \let | struct => \lam (f : A.S -> B.S) => \lam (x y : A.S) => f (x |+| {A} y) = f x |+| {B} f y
           | structT => \lam (f : A.S -> B.S) => \Pi (x y : A.S) -> struct f x y
           | homoSigma => \Sigma (h : A.S -> B.S) (structT h)
           | structSet : \Pi (f : A.S -> B.S) -> \Pi (x y : A.S) -> isSet (struct f x y) =>
             \lam f => \lam x y =>
               isProp=>isSet (struct f x y) (B.is_set (f (x |+| {A} y)) (f x |+| {B} f y))
           | structTSet : \Pi (f : A.S -> B.S) -> isSet (structT f) =>
             \lam f => piSet {A.S} (\lam x => \Pi (y : A.S) -> struct f x y) (\lam x =>
               piSet {A.S} (\lam y => struct f x y) (\lam y => structSet f x y)
             )
           | homoSigma_isSet => sigmaSet {A.S -> B.S} {structT} (Set.hom_set A B) (structTSet)
           | sect => \new Section {
             | A => Homo {A} {B}
             | B => homoSigma
             | f (x : Homo {A} {B}) => (x.h, x.equ)
             | ret b => \new Homo {A} {B} b.1 b.2
             | ret_f => qed
             }
      \in retractsSet sect homoSigma_isSet

    \func zero : Semigroup \cowith {
      | S => Empty
      | is_set => empty_isSet
      | op => absurd
      | assoc => \lam x => absurd x
      }

    \func one : Semigroup \cowith {
      | S => Unit
      | is_set => unit_isSet
      | op => \lam u1 => \lam u2 => unit
      | assoc => \lam _ _ _ => idp
    }

    \func product (A B : Semigroup) : Semigroup \cowith {
      | S => \Sigma A.S B.S
      | is_set => product_isSet A B
      | op => \lam s1 s2 => (s1.1 |+| {A} s2.1, s1.2 |+| {B} s2.2)
      | assoc x y z =>
        SigmaExt {A.S} (\lam _ => B.S)
                 ((x.1 |+| {A} y.1) |+| {A} z.1, (x.2 |+| {B} y.2) |+| {B} z.2)
                 (x.1 |+| {A} (y.1 |+| {A} z.1), x.2 |+| {B} (y.2 |+| {B} z.2))
                 (A.assoc x.1 y.1 z.1) (B.assoc x.2 y.2 z.2)
      }
  }

\module SemigroupCategory \where {
  \open Semigroup

  \func Semi : Cat {Semigroup} =>
      setBasedCategory Semigroup
                       (\lam x => x)
                       (\lam A B => Homo {A} {B})
                       (\lam {A} {B} (f : Homo {A} {B}) => f.h)
                       (\lam {A} {B} => homo_isSet A B)
                       id
                       (\lam {_} => idp)
                       (\lam f g => comp f g)
                       (\lam _ _ => idp)
                       (\lam f g eq => equiv f g eq)

  \func initial : Initial {Semi} zero \cowith {
    | initial P => \new Singleton {
      | T => zero ->> P
      | t => \new Homo {zero} {P} absurd (\lam x => absurd x)
        | prop (m1 m2 : Homo {zero} {P}) =>
          equiv m1 m2 (functExt (\lam x => absurd x))
      }
    }

  \func terminal : Terminal {Semi} one \cowith {
    | terminal P => \new Singleton {
      | T => P ->> one
      | t => \new Homo {P} {one} (\lam _ => unit) (\lam _ _ => idp)
      | prop (m1 m2 : Homo {P} {one}) =>
        equiv m1 m2 (functExt (\lam x => unit_isProp (m1.h x) (m2.h x)))
      }
    }

  -- FIXME: copypaste from PointedSet!
  \func cartesian_product (A B : Semigroup) : Product2 {Semi} A B =>
      \let | A*B : Semigroup => product A B
           | p1 : Homo {A*B} {A} => \new Homo {A*B} {A} (\lam x => x.1) (\lam _ _ => idp)
           | p2 : Homo {A*B} {B} => \new Homo {A*B} {B} (\lam x => x.2) (\lam _ _ => idp) \in
      \new Product2 {Semi} A B A*B p1 p2 {
        | prod (C : Semigroup) (q1 : Homo {C} {A}) (q2 : Homo {C} {B}) =>
          \let m : Homo {C} {A*B}  => \new Homo {C} {A*B} {
            | h => (\lam x => (q1.h x, q2.h x))
            | equ x y =>
              SigmaExt {A.S} (\lam _ => B.S)
                       (q1.h (x |+| {C} y), q2.h (x |+| {C} y))
                       (q1.h x |+| {A} q1.h y, (q2.h x) |+| {B} q2.h y)
                       (q1.equ x y) (q2.equ x y)
          } \in
          \new Unique (C ->> {Semi} A*B) (\lam m => \Sigma (p1 cmp {Semi} m = q1) (p2 cmp {Semi} m = q2)) {
            | elem => m
            | prop =>
              \let | p1_m => p1 cmp {Semi} m
                   | p2_m => p2 cmp {Semi} m \in
              (equiv p1_m q1 (functExt (\lam x => qed (q1.h x))),
               equiv p2_m q2 (functExt (\lam x => qed (q2.h x))))
            | unique (f : Homo {C} {A*B}) s =>
              equiv m f (functExt (\lam x =>
                \let | fx => f.h x
                     | fst : fx.1 = q1.h x => (functExtElim (equivElim s.1)) x
                     | snd : fx.2 = q2.h x => (functExtElim (equivElim s.2)) x \in
                inv (pmap2 (\lam u => \lam w => (u, w)) fst snd)
              ))
            }
        }
}
