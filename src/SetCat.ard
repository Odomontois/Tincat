\import Cat
\import Product
\import Set
\import Unique
\import lib.Data.Empty
\import lib.Data.Unit
\import lib.HLevel
\import lib.Paths
\import Terminal

\record Set (S : \Type)
            (is_set : isSet S)
  \where {
    \func id {X : \Type} => \lam (x : X) => x

    \func hom_set (X Y : Set) : isSet (X.S -> Y.S) => piSet Y.is_set

    \func comp {X Y Z : \Type} (f : Y -> Z) (g : X -> Y) : X -> Z => \lam (x : X) => f (g (x))

    \func r_unit {X Y : \Type} (f : X -> Y) : comp f id = f => functExt (\lam x => qed (f x))

    \func l_unit {X Y : \Type} (f : X -> Y) : comp id f  = f => functExt (\lam x => qed (f x))

    \func assoc {A B C D : \Type}
                (f : C -> D)
                (g : B -> C)
                (h : A -> B) : comp f (comp g h) = comp (comp f g) h =>
      functExt (\lam x => qed (f (g (h (x)))))
  }

\func SetC : Cat \cowith {
  | Ob => Set
  | Hom (X Y : Set) => X.S -> Y.S
  | homSet {X Y : Set} => Set.hom_set X Y
  | id {ob : Set} => Set.id
  | comp {x y z : Set} => Set.comp {x.S} {y.S} {z.S}
  | l_unit {x y : Set} => Set.l_unit {x.S} {y.S}
  | r_unit {x y : Set} => Set.r_unit {x.S} {y.S}
  | assoc {a b c d : Set} => Set.assoc {a.S} {b.S} {c.S} {d.S}
  }

\func one : Set => \new Set Unit unit_isSet

\func empty_isSet : isSet Empty =>
  \lam (x y : Empty) => absurd {\Pi (e1 e2 : x = y) -> e1 = e2} x

\func empty : Set => \new Set Empty empty_isSet

\func one_is_terminal : Terminal {SetC} one \cowith {
  | terminal (X : Set) => \new Singleton {
    | T => X ->> {SetC} one
    | t (x : X.S) => unit
    | prop m1 m2 => functExt (\lam x => unit_isProp (m1 x) (m2 x))
    }
  }

\func empty_is_initial : Initial {SetC} empty \cowith {
  | initial X => \new Singleton {
    | T => empty ->> {SetC} X
    | t a => absurd a
    | prop m1 m2 => functExt (\lam x => absurd x)
    }
  }

\func product_isSet (X Y : Set) : isSet (\Sigma X.S Y.S) =>
  pairSet X.is_set Y.is_set

\func set_product (A : Set) (B : Set) : Product2 {SetC} =>
  \let | p : Set => \new Set {
         | S => \Sigma (x : A.S) (y : B.S)
         | is_set => product_isSet A B
         }
       | p1 : p.S -> A.S => \lam s => s.1
       | p2 : p.S -> B.S => \lam s => s.2 \in
  \new Product2 {SetC} A B p p1 p2 {
    | prod (X : Set) (q1 : X.S -> A.S) (q2 : X.S -> B.S) =>
      \let m : X.S -> p.S => \lam x => (q1 x, q2 x) \in
      \new Unique {
        | A => X.S -> p.S
        | B pr => \Sigma (Set.comp p1 pr = q1) (Set.comp p2 pr = q2)
        | elem => m
        | prop => (functExt (\lam x => qed (q1 x)), functExt (\lam x => qed (q2 x)))
        | unique f s =>
          functExt (\lam x =>
            \let | fx => f x
                 | fst : fx.1 = q1 x => (functExtElim s.1) x
                 | snd : fx.2 = q2 x => (functExtElim s.2) x \in
              inv (pmap2 (\lam u w => (u, w)) fst snd)
          )
        }
    }

\func setBasedCategory (Ob : \Type)
                       (set : \Pi Ob -> Set)
                       (Hom : Ob -> Ob -> \Set)
                       (homo : \Pi {A B : Ob} -> Hom A B -> (Set.S {set A} -> Set.S {set B}))
                       (hom_isSet : \Pi {a b : Ob} -> isSet (Hom a b))
                       (id : \Pi {A : Ob} -> Hom A A)
                       (id_e : \Pi {A : Ob} -> homo (id {A}) = Set.id)
                       (comp : \Pi {a b c : Ob} -> Hom b c -> Hom a b -> Hom a c )
                       (comp_e : \Pi {a b c : Ob} (f : Hom b c) (g : Hom a b) -> homo (comp f g) = Set.comp (homo f) (homo g))
                       (equiv : \Pi {A B : Ob} (f g : Hom A B) (e : homo f = homo g) -> f = g) : Cat {Ob} Hom hom_isSet id comp
  \cowith {
    | l_unit {A} {B} f =>
      \let | composed : Hom A B => comp id f
           | left : homo composed = homo f =>
             (comp_e id f) *>
             pmap (\lam x => Set.comp x (homo f)) id_e *>
             (Set.l_unit (homo f)) \in
      equiv composed f left
    | r_unit {A} {B} f =>
      \let | composed : Hom A B => comp f id
           | right : homo composed = homo f =>
             (comp_e f id) *>
             pmap (\lam x => Set.comp (homo f) x) id_e *>
             (Set.r_unit (homo f)) \in
      equiv composed f right
    | assoc {A} {B} {C} {D} e f g =>
      \let | left : Hom A D => comp (comp e f) g
           | right : Hom A D => comp e (comp f g)
           | ass : homo left = homo right =>
             comp_e (comp e f) g *>
             pmap (\lam x => Set.comp x (homo g)) (comp_e e f) *>
             Set.assoc (homo e) (homo f) (homo g) *>
             (inv (comp_e e (comp f g) *> pmap (\lam x => Set.comp (homo e) x) (comp_e f g)))
           \in
      equiv left right ass
    }
