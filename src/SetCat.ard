\import Cat
\import Product
\import Set
\import Unique
\import Util
\import lib.Data.Empty
\import lib.Data.Unit
\import lib.HLevel
\import lib.Paths
\import Terminal

\record Set (S : \Type)
            (is_set : isSet S)
  \where {
    \func id {X : \Type} => \lam (x : X) => x

    \func hom_set (X Y : Set) : isSet (X.S -> Y.S) => piSet {X.S} (\lam _ => Y.S) (\lam _ => Y.is_set)

    \func comp {X Y Z : \Type} (f : Y -> Z) (g : X -> Y) : X -> Z => \lam (x : X) => f (g (x))

    \func r_unit {X Y : \Type} (f : X -> Y) : comp f id = f => functExt (\lam x => qed (f x))

    \func l_unit {X Y : \Type} (f : X -> Y) : comp id f  = f => functExt (\lam x => qed (f x))

    \func assoc {A B C D : \Type}
                (f : C -> D)
                (g : B -> C)
                (h : A -> B) : comp f (comp g h) = comp (comp f g) h =>
      functExt (\lam x => qed (f (g (h (x)))))
  }

\func SetC : Cat \cowith {
  | Ob => Set
  | Hom (X Y : Set) => X.S -> Y.S
  | homSet {X Y : Set} => Set.hom_set X Y
  | id {ob : Set} => Set.id
  | comp {x y z : Set} => Set.comp {x.S} {y.S} {z.S}
  | l_unit {x y : Set} => Set.l_unit {x.S} {y.S}
  | r_unit {x y : Set} => Set.r_unit {x.S} {y.S}
  | assoc {a b c d : Set} => Set.assoc {a.S} {b.S} {c.S} {d.S}
  }

\func one : Set => \new Set Unit unit_isSet

\func empty_isSet : isSet Empty =>
  \lam (x y : Empty) => absurd {\Pi (e1 e2 : x = y) -> e1 = e2} x

\func empty : Set => \new Set Empty empty_isSet

\func one_is_terminal : Terminal {SetC} one \cowith {
  | terminal (X : Set) => \new Singleton {
    | T => X ->> {SetC} one
    | t (x : X.S) => unit
    | prop m1 m2 => functExt (\lam x => unit_isProp (m1 x) (m2 x))
    }
  }

\func empty_is_initial : Initial {SetC} empty \cowith {
  | initial X => \new Singleton {
    | T => empty ->> {SetC} X
    | t a => absurd a
    | prop m1 m2 => functExt (\lam x => absurd x)
    }
  }

\func product_isSet (X Y : Set) : isSet (\Sigma X.S Y.S) =>
  pairSet X.is_set Y.is_set

\func set_product (A : Set) (B : Set) : Product2 {SetC} =>
  \let | p : Set => \new Set {
         | S => \Sigma (x : A.S) (y : B.S)
         | is_set => product_isSet A B
         }
       | p1 : p.S -> A.S => \lam s => s.1
       | p2 : p.S -> B.S => \lam s => s.2 \in
  \new Product2 {SetC} A B p p1 p2 {
    | prod (X : Set) (q1 : X.S -> A.S) (q2 : X.S -> B.S) =>
      \let m : X.S -> p.S => \lam x => (q1 x, q2 x) \in
      \new Unique {
        | A => X.S -> p.S
        | B pr => \Sigma (Set.comp p1 pr = q1) (Set.comp p2 pr = q2)
        | elem => m
        | prop => (functExt (\lam x => qed (q1 x)), functExt (\lam x => qed (q2 x)))
        | unique f s =>
          functExt (\lam x =>
            \let | fx => f x
                 | fst : fx.1 = q1 x => (functExtElim s.1) x
                 | snd : fx.2 = q2 x => (functExtElim s.2) x \in
              inv (pmap2 (\lam u w => (u, w)) fst snd)
          )
        }
    }

\class SetBasedCat  (set : \Pi Ob -> Set)
                    (homo : \Pi {A B : Ob} -> Hom A B -> (Set.S {set A} -> Set.S {set B}))
                    (id_e : \Pi {A : Ob} -> homo (id {A}) = Set.id)
                    (comp_e : \Pi {a b c : Ob} (f : Hom b c) (g : Hom a b) -> homo (comp f g) = Set.comp (homo f) (homo g))
                    (equiv : \Pi {A B : Ob} (f g : Hom A B) (e : homo f = homo g) -> f = g) \extends CatStruct
  \where {
    \func category (s : SetBasedCat) : Cat {s.Ob} s.Hom s.homSet s.id s.comp \cowith {
      | l_unit {A} {B} f =>
        \let | composed : Hom A B => s.comp s.id f
             | left : s.homo composed = s.homo f =>
               (s.comp_e s.id f) *>
               pmap (\lam x => Set.comp x (s.homo f)) s.id_e *>
               (Set.l_unit (s.homo f)) \in
               s.equiv composed f left
      | r_unit {A} {B} f =>
        \let | composed : Hom A B => s.comp f s.id
             | right : s.homo composed = s.homo f =>
               (s.comp_e f s.id) *>
               pmap (\lam x => Set.comp (s.homo f) x) s.id_e *>
               (Set.r_unit (s.homo f)) \in
               s.equiv composed f right
      | assoc {A} {B} {C} {D} e f g =>
        \let | left : Hom A D => s.comp (s.comp e f) g
             | right : Hom A D => s.comp e (s.comp f g)
             | ass : s.homo left = s.homo right =>
               s.comp_e (s.comp e f) g *>
               pmap (\lam x => Set.comp x (s.homo g)) (s.comp_e e f) *>
               Set.assoc (s.homo e) (s.homo f) (s.homo g) *>
               (inv (s.comp_e e (s.comp f g) *> pmap (\lam x => Set.comp (s.homo e) x) (s.comp_e f g)))
        \in s.equiv left right ass
    }

--    \func setBasedProduct (T : \Type)
--                          (cat : SetBasedCat {T})
--                          (prod : \Pi (A B : T) ->
--                            \Sigma (A*B : T) (u : Set.S {set A*B} = (\Sigma (x : Set.S {set A}) (y : Set.S {set B})))
--                                   (p1 : cat.Hom A*B A) (cat.homo p1 = (\lam (x : Set.S {set A*B}) => (transportTerm u x).1))
--                                   (p2 : cat.Hom A*B B) (cat.homo p2 = (\lam (x : Set.S {set A*B}) => (transportTerm u x).2))
--                                   (\Pi (C : T) (q1 : cat.Hom C A) (q2 : cat.Hom C B) ->
--                                     \Sigma (m : cat.Hom C A*B) (cat.homo m = (\lam x => transportTerm (inv u) ((cat.homo q1) x, (cat.homo q2) x))))
--                          ) : \Pi (A B : T) -> Product2 A B => \lam A B =>
--        \let | A*B : T => (prod A B).1
--             | p1 : cat.Hom A*B A => (prod A B).3
--             | p2 : cat.Hom A*B B => (prod A B).5
--             | full_cat => category cat
--             | equivElim {A B : T}{f g : cat.Hom A B}(e : f = g) : cat.homo f = cat.homo g =>
--                          pmap {cat.Hom A B} {Set.S {set A} -> Set.S {set B}} (\lam (x : cat.Hom A B) => cat.homo x) e
--             \in
--          \new Product2 {full_cat} A B A*B p1 p2 {
--            | prod (C : T) (q1 : cat.Hom C A) (q2 : cat.Hom C B) =>
--              \let m : cat.Hom C A*B => ((prod A B).7 C q1 q2).1
--              \in
--              \new Unique (C ->> {full_cat} A*B) (\lam m => \Sigma (p1 cmp {full_cat} m = q1) (p2 cmp {full_cat} m = q2)) {
--                | elem => m
--                | prop =>
--                  \let | p1_m => p1 cmp {full_cat} m
--                       | p2_m => p2 cmp {full_cat} m \in
--                  (cat.equiv p1_m q1 (functExt (\lam x => qed ((cat.homo q1) x))),
--                   cat.equiv p2_m q2 (functExt (\lam x => qed ((cat.homo q2) x))))
--                | unique (f : cat.Hom {C} {A*B}) s =>
--                  equiv m f (functExt (\lam x =>
--                    \let | fx => (homo f) x
--                         | fst : fx.1 = (homo q1) x => (functExtElim (equivElim s.1)) x
--                         | snd : fx.2 = (homo q2) x => (functExtElim (equivElim s.2)) x \in
--                    inv (pmap2 (\lam u => \lam w => (u, w)) fst snd)
--                  ))
--                }
--            }
  }
