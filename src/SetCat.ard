\import Cat
\import Product
\import Set
\import Unique
\import Util
\import Logic
\import HLevel
\import Paths
\import Terminal



\func one_is_terminal : Terminal {} one \cowith {
  | terminal (X : Set) => \new Singleton {
    | T => X ->> {SetC} one
    | val (x : X.S) => unit
    | prop m1 m2 => functExt (\lam x => unit_isProp (m1 x) (m2 x))
    }
  }

\func empty_is_initial : Initial {SetC} empty \cowith {
  | initial X => \new Singleton {
    | T => empty ->> {SetC} X
    | val a => absurd a
    | prop m1 m2 => functExt (\lam x => absurd x)
    }
  }

\func product_isSet (X Y : Set) : isSet (\Sigma X.S Y.S) =>
  pairSet X.is_set Y.is_set

\func set_product (A : Set) (B : Set) : Product2 {SetC} =>
  \let | p : Set => \new Set {
         | S => \Sigma (x : A.S) (y : B.S)
         | is_set => product_isSet A B
         }
       | p1 : p.S -> A.S => \lam s => s.1
       | p2 : p.S -> B.S => \lam s => s.2 \in
  \new Product2 {SetC} A B p p1 p2 {
    | prod (X : Set) (q1 : X.S -> A.S) (q2 : X.S -> B.S) =>
      \let m : X.S -> p.S => \lam x => (q1 x, q2 x) \in
      \new Unique {
        | A => X.S -> p.S
        | B pr => \Sigma (Set.comp p1 pr = q1) (Set.comp p2 pr = q2)
        | elem => m
        | prop => (functExt (\lam x => qed (q1 x)), functExt (\lam x => qed (q2 x)))
        | unique f s =>
          functExt (\lam x =>
            \let | fx => f x
                 | fst : fx.1 = q1 x => (functExtElim s.1) x
                 | snd : fx.2 = q2 x => (functExtElim s.2) x \in
              inv (pmap2 (\lam u w => (u, w)) fst snd)
          )
        }
    }

\record SetBasedCat (set : \Pi Ob -> Set)
                    (homo : \Pi {A B : Ob} -> Hom A B -> (Set.S {set A} -> Set.S {set B}))
                    (id_e : \Pi {A : Ob} -> homo (id {A}) = Set.id)
                    (comp_e : \Pi {a b c : Ob} (f : Hom b c) (g : Hom a b) -> homo (comp f g) = Set.comp (homo f) (homo g))
                    (equiv : \Pi {A B : Ob} (f g : Hom A B) (e : homo f = homo g) -> f = g) \extends CatStruct
  \where {
    \func category (s : SetBasedCat) : PreCat {s.Ob} s.Hom s.homSet s.id s.comp \cowith {
      | l_unit {A} {B} f =>
        \let | composed : Hom A B => s.comp s.id f
             | left : s.homo composed = s.homo f =>
               (s.comp_e s.id f) *>
               pmap (\lam x => Set.comp x (s.homo f)) s.id_e *>
               (Set.l_unit (s.homo f)) \in
        s.equiv composed f left
      | r_unit {A} {B} f =>
        \let | composed : Hom A B => s.comp f s.id
             | right : s.homo composed = s.homo f =>
               (s.comp_e f s.id) *>
               pmap (\lam x => Set.comp (s.homo f) x) s.id_e *>
               (Set.r_unit (s.homo f)) \in
        s.equiv composed f right
      | assoc {A} {B} {C} {D} e f g =>
        \let | left : Hom A D => s.comp (s.comp e f) g
             | right : Hom A D => s.comp e (s.comp f g)
             | ass : s.homo left = s.homo right =>
               s.comp_e (s.comp e f) g *>
               pmap (\lam x => Set.comp x (s.homo g)) (s.comp_e e f) *>
               Set.assoc (s.homo e) (s.homo f) (s.homo g) *>
               (inv (s.comp_e e (s.comp f g) *> pmap (\lam x => Set.comp (s.homo e) x) (s.comp_e f g))) \in
        s.equiv left right ass
    }

    \record SetBasedProduct {s : SetBasedCat}
                            (A B A*B : PreCat.Ob {s})
                            (u : Set.S {s.set A*B} = (\Sigma (x : Set.S {s.set A}) (y : Set.S {s.set B})))
                            (p1 : s.Hom A*B A) (p1_e : s.homo p1 = (\lam (x : Set.S {s.set A*B}) => (transportTerm u x).1))
                            (p2 : s.Hom A*B B) (p2_e : s.homo p2 = (\lam (x : Set.S {s.set A*B}) => (transportTerm u x).2))
                            (ump : \Pi (C : s.Ob) (q1 : s.Hom C A) (q2 : s.Hom C B) ->
                              \Sigma (m : s.Hom C A*B) (s.homo m = (\lam x => transportTerm (inv u) ((s.homo q1) x, (s.homo q2) x))))

    \func product {s : SetBasedCat} {A B A*B : s.Ob} (sp : SetBasedProduct {s} A B A*B) : Product2 A B A*B =>
      \let | cat => category s
           | equivElim {X Y : PreCat.Ob {s}} {f g : s.Hom X Y} (e : f = g) : s.homo f = s.homo g =>
             pmap (\lam (x : s.Hom X Y) => s.homo x) e
      \in
      \new Product2 {cat} A B A*B sp.p1 sp.p2 {
        | prod (C : s.Ob) (q1 : C ->> {cat} A) (q2 : C ->> {cat} B) =>
          \let | m : s.Hom C sp.A*B => (sp.ump C q1 q2).1 \in
          \new Unique (C ->> {cat} A*B) (\lam m => \Sigma (sp.p1 cmp {cat} m = q1) (sp.p2 cmp {cat} m = q2)) m {
            | prop =>
              \let | p1_m => sp.p1 cmp {cat} m
                   | p2_m => sp.p2 cmp {cat} m \in
              (s.equiv p1_m q1 (functExt (\lam x =>
                 functExtElim (s.comp_e sp.p1 m) x *>
                 pmap (s.homo sp.p1) (functExtElim (sp.ump C q1 q2).2 x) *>
                 functExtElim (sp.p1_e) (transportTerm (inv sp.u) ((s.homo q1) x, (s.homo q2) x)) *>
                 pmap (\lam a => a.1) (transportTermEq' (sp.u) ((s.homo q1) x, (s.homo q2) x))
              )),
               s.equiv p2_m q2 (functExt (\lam x =>
                 functExtElim (s.comp_e sp.p2 m) x *>
                 pmap (s.homo sp.p2) (functExtElim (sp.ump C q1 q2).2 x) *>
                 functExtElim (sp.p2_e) (transportTerm (inv sp.u) ((s.homo q1) x, (s.homo q2) x)) *>
                 pmap (\lam a => a.2) (transportTermEq' (sp.u) ((s.homo q1) x, (s.homo q2) x))
              )))
            | unique (f : C ->> {cat} A*B) sig =>
               s.equiv m f (functExt (\lam x =>
                 \let | fx => (s.homo f) x
                      | e1 : (transportTerm sp.u fx).1 = (s.homo q1) x =>
                        inv ((functExtElim sp.p1_e) ((s.homo f) x)) *>
                        inv ((functExtElim (s.comp_e sp.p1 f)) x) *>
                        (functExtElim (pmap s.homo sig.1)) x

                      | e2 : (transportTerm sp.u fx).2 = (s.homo q2) x =>
                        inv ((functExtElim sp.p2_e) ((s.homo f) x)) *>
                        inv ((functExtElim (s.comp_e sp.p2 f)) x) *>
                        (functExtElim (pmap s.homo sig.2)) x

                      | e3 : (transportTerm sp.u ((s.homo f) x)) = ((s.homo q1) x, (s.homo q2) x) => pairExt e1 e2
                      | goal : (s.homo f) x = (s.homo m) x =>
                        inv (transportTermEq sp.u ((s.homo f) x)) *>
                        pmap (transportTerm (inv sp.u)) e3 *>
                        inv ((functExtElim (sp.ump C q1 q2).2) x)
                 \in inv goal
                 )
               )
            }
        }
  }