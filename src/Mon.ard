\import lib.HLevel
\import Cat
\import lib.Paths
\import Set

\record Monoid {Ob : \Set}
               (comp : \Pi Ob -> Ob -> Ob)
               (unit : Ob)
               (assoc : \Pi {a b c : Ob} -> comp (comp a b) c = comp a (comp b c))

\func \infix 6 |+| {m : Monoid} (a b : m.Ob) : m.Ob => m.comp a b

\record Homo {m1 m2 : Monoid}
             (f : m1.Ob -> m2.Ob)
             (keep : \Pi (x y : m1.Ob) -> f (x |+| {m1} y) = f (x) |+| {m2} f (y))

\func id_homo {m : Monoid} : Homo {m} {m} \cowith
  | f => \lam x => x
  | keep => \lam (x y : m.Ob) => qed (x |+| {m} y)

\func homo_comp {a b c : Monoid}
                (h1 : Homo {b} {c})
                (h2 : Homo {a} {b}) : Homo {a} {c} =>
  \let f : a.Ob -> c.Ob => func_comp h1.f h2.f \in
  \new Homo {a} {c} f {
    | keep => \lam (x y : a.Ob) =>
      pmap h1.f (h2.keep x y) *> h1.keep (h2.f x) (h2.f y)
  }

--\func id_homo_left {m1 m2 : Monoid}
--                   (h : Homo {m1} {m2}) : (homo_comp {m1} {m1} {m2} h id_homo) = h =>
--  pmap2 {m1.Ob -> m2.Ob} {\Pi (f : m1.Ob -> m2.Ob) (x y : m1.Ob) -> f (x |+| {m1} y) = f (x) |+| {m2} f (y)}
--        (\lam f keep => Homo f (keep f)) (id) {?} \where {
--
--        }

\func Mon : Cat \cowith {
  | Ob => Monoid
  | Hom => \lam (x y : Monoid) => Homo {x} {y}
  | homSet => {?}
  | id => id_homo
  | comp => \lam {a b c : Monoid} (h1 : Homo {b} {c}) (h2 : Homo {a} {b}) => homo_comp h1 h2
  | l_unit => {?}
  | r_unit => {?}
  | assoc => {?}
  }
